##
## Author(s):
##  - Dimitri Merejkowsky <dmerejkowsy@aldebaran-robotics.com>
##  - Cedric GESTES <gestes@aldebaran-robotics.com>
##
## Copyright (C) 2009, 2010 Aldebaran Robotics
##

"""This module contains:
ProjectBuilder a wrapper around cmake, make and msbuild.

Gotcha:
=======
Calling cmake -DCMAKE_BUILD_TYPE=debug and
msbuild foo.sln causes foo to be build in release.
(it's a CMake / visual studio "feature")

This is why we should keep the same build dir on windows
"""

import os
import shlex
import logging
import qibuild.sh
import qibuild.build
from   qibuild.toc.project import Project

LOGGER = logging.getLogger("qibuild.projectbuilder")

class ProjectBuilder(Project):
    """A build configuration has:
      * a set of CMake flags
      * a toolchain_name

      There's  a bunch of update_* method that
      any class can call
    """
    def __init__(self, directory, tob, build_directory_name):
        Project.__init__(self, directory)
        self.cmake_flags     = list()
        self.build_directory = None
        self.update(tob, build_directory_name)

    def update(self, tob, build_directory_name):
        """ Update cmake_flags
           - add flags from the build_config
           - add flags from the project config
           - add flags from the command line
        """
        if tob.build_config:
            build_config_flags = tob.configstore.get("build", tob.build_config, "cmake", "flags", default=None)
            if build_config_flags:
                self.cmake_flags.extend(shlex.split(build_config_flags))

        project_flags = tob.configstore.get(self.name, "build", "cmake", "flags", default=None)
        if project_flags:
            self.cmake_flags.extend(shlex.split(project_flags))

        if tob.build_type:
            self.flags.append("CMAKE_BUILD_TYPE=%s" % (tob.build_type.toupper()))

        if tob.toolchain_name:
            self.flags.append("QI_TOOLCHAIN_NAME=%s" % (tob.toolchain_name))

        if tob.cmake_flags:
            # See big __doc__ for why we use append here
            self.cmake_flags.extend(tob.cmake_flags)
        self.build_directory = os.path.join(self.directory, build_directory_name)
        #create the build_directory if it does not exists
        if not os.path.exists(self.build_directory):
            os.makedirs(self.build_directory)


    def __str__(self):
        res = Project.__str__(self)
        res += "  cmake_flags     = %s\n"     % self.cmake_flags
        res += "  build_directory = %s\n" % self.build_directory
        return res



def get_qibuild_cmake_framework_path():
    """ return the path to the QiBuild Cmake framework """
    return os.path.normpath(os.path.join(os.path.dirname(__file__), "..", "..", "cmake"))

def bootstrap_project(project, dep_sdk_dirs):
    """Generate the find_deps.cmake for the given project
    """
    build_dir = project.build_directory

    to_write  = "#############################################\n"
    to_write += "#QIBUILD AUTOGENERATED FILE. DO NOT EDIT.\n"
    to_write += "#############################################\n"
    to_write += "\n"
    to_write += "#QIBUILD CMAKE FRAMEWORK PATH:\n"
    to_write += "set(CMAKE_MODULE_PATH \"%s\")\n" % get_qibuild_cmake_framework_path()
    to_write += "\n"
    to_write += "#DEPENDENCIES:\n"
    for dep_sdk_dir in dep_sdk_dirs:
        to_write += "list(APPEND CMAKE_PREFIX_PATH \"%s\")\n" % qibuild.sh.to_posix_path(dep_sdk_dir)

    output_path = os.path.join(build_dir, "dependencies.cmake")
    with open(output_path, "w") as output_file:
        output_file.write(to_write)

    LOGGER.debug("Wrote to %s:\n%s", output_path, to_write)


def configure_project(project, flags=None, toolchain_file=None, generator=None):
    """ Call cmake with correct options
    if toolchain_file is None a t001chain file is generated in the cmake binary directory.
    if toolchain_file is "", then CMAKE_TOOLCHAIN_FILE is not specified.
    """

    #TODO: guess generator

    if not os.path.exists(project.directory):
        raise ConfigureException("source dir: %s does not exist, aborting" % project.directory)

    if not os.path.exists(os.path.join(project.directory, "CMakeLists.txt")):
        LOGGER.info("Not calling cmake for %s", os.path.basename(project.directory))
        return

    # Set generator (mandatory on windows, because cmake does not
    # autodetect visual studio compilers very well)
    cmake_args = []
    if generator:
        cmake_args.extend(["-G", generator])

    # Make a copy so that we do not modify
    # the list used by the called
    if flags:
        cmake_flags = flags[:]
    else:
        cmake_flags = list()
    cmake_flags.extend(project.cmake_flags)

    if toolchain_file:
        cmake_flags.append("CMAKE_TOOLCHAIN_FILE=" + toolchain_file)

    cmake_args.extend(["-D" + x for x in cmake_flags])

    qibuild.build.cmake(project.directory, project.build_directory, cmake_args)


def make_project(project, build_type, num_jobs=1, nmake=False, target=None):
    """Build the project"""
    build_dir = project.build_directory
    LOGGER.debug("[%s]: building in %s", project.name, build_dir)
    if sys.platform.startswith("win32") and not nmake:
        sln_files = glob.glob(build_dir + "/*.sln")
        if len(sln_files) == 0:
            LOGGER.debug("Not calling msbuild for %s", os.path.basename(build_dir))
            return

        if len(sln_files) != 1:
            err_message = "Found several sln files: "
            err_message += ", ".join(sln_files)
            raise MakeException(err_message)
        sln_file = sln_files[0]
        qibuild.build.build_vc(sln_file, build_type=build_type, target=target)
    else:
        if not os.path.exists(os.path.join(build_dir, "Makefile")):
            LOGGER.debug("Not calling make for %s", os.path.basename(build_dir))
            return
        if sys.platform.startswith("win32"):
            qibuild.build.build_nmake(build_dir, target=target)
        else:
            qibuild.build.build_unix(build_dir, num_jobs=num_jobs, target=target)
