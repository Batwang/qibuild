How to write a library
======================

This is merely a convention, but you are advised to follow it, especially
if you are working in a large project.

Let's say you have a +foo+ library.

You have the following files:

 * foo.h   : the public header of the +foo+ library.
   It contains the public API, and include the least possible number of other
   headers. (Use of forward declarations, and +PIMPL+ implementations are
   recommanded)
 * foo.cpp  : implementation of the foo.h functions

 * foo_private.h : private header of the +foo+ library. This one
   may include a bunch of other headers
 * foo_private.cpp : private implementation.

 * foo_test.cpp : You would not *dare* writing a library without unit tests, would you?

Proposed layout
--------------

----
fooproject
|__ foo
    |__ foo
    |   |__ foo.h
    |   |__ foo.cpp
    |   |__ src
    |       |__ foo_private.h
    |       |__ foo_private.cpp
    |__ test
        |__ foo_test.cpp
----

* The full path to the public header is  +foo/foo/foo.h+

* The private code is put in a +src+ sub-directory

CMake
----

[source, cmake]
----
# Main CMakeLists
cmake_minimum_required(VERSION 2.8)
include("qibuild.cmake")
project(fooproject)

add_subdirectory(foo)
add_subdirectory(foo/test)

# foo/CMakeLists.txt:
qi_create_lib(foo
  SRC foo/foo.h
      foo/foo.cpp
      foo/src/foo_private.h
      foo/src/foo_private.cpp
  PUBLIC_HEADER
      foo/foo.h
  SUBFOLDER
      foo
)

qi_stage_lib(foo)

# foo/test/CMakeLists.txt
qi_create_gtest(foo_test
  SRC
    foo_test.cpp
  DEPENDS
    gtest
    foo)
----


Rationale
---------
You will note that:

  * The only time we call +include_directories()+ is when we are staging
  the +foo+ library.

  * Everything that need a +foo+ header must use

[source, c]
----
#include <foo/...>
----
This way, we are sure that the code we use can be re-distributed when
the headers are installed, and that the path to find the headers while in
the source tree does not differ from the paths to find the installed headers.
That's why we have to put +foo.h+ in a +foo+ subdirectory

 * The test can use both the public API and the private implementation

 * Let's assume you have two libraries, +foo+ and +bar,+ and a +foobar+ executable that
 need code from +foo+ and +bar+.

With the proposed layout, you have something like:
----

lib
|__ foo
|    |__ foo
|    |    |__ foo.h
|    bar
|    |__ bar
|        |__ bar.h
foobar
    |__ foobar.cpp

----

You may want to get rid of the useless redundancy +foo/foo+, +bar/bar+, and do this
instead:

----

lib
|__ foo
|    |__ foo.h
|    bar
|    |__ bar.h
foobar
    |__ foobar.cpp
----

But, let's assume you have

[source, cmake]
----
qi_use_lib(foobar foo)
----

instead of

[source, cmake]
----
qi_use_lib(foobar foo bar)
----

In the first layout, you will have an error during *compile time*, looking like

----
bar/bar.h : no such file or directory
----

(because the include directory that has been staged for +foo+ is different from
the include directory that has been staged for +bar+)
But, using the second layout, you will have an error during *link time*, looking like

----
undefined referecence to `bar_func'
----

(because the include directory that was staged was always the same: +lib+)


NOTE: For large libraries, also consider using link:submodule.html[qi_submodule]
