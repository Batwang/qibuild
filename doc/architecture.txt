Architecture
============

== qiBuild ==
qiBuild is a simple tool that builds projects taking dependencies and toolchains into account.

We have strong requirements for it:

* to be as standard as possible
* support cross-compilation
* support visual-studio
* support building for multiple platforms with the same source tree

How does it work?

=== Toolchains ===
Toolchains are managed by qiToolchain. The default toolchain is called "system". The system
toolchain represents your system, so that libraries and headers will be searched for in your system.
Other toolchains use binary packages.

A toolchain is composed of:

* binary packages
* a list of provided projects (a binary package can provide multiple projects)
* optional CMake toolchain file to set cross-compilation specific options (CC, CXX, rootfs, ...)
* optional CMake flags

Each package follow a standard SDK layout: compatible with the Filesystem Hierarchy Standard (FHS) and CMake guidelines.

=== Packages ===
A binary package is an archive with a manifest that describes the package (runtime dependencies,
provided packages, ...) with a standard SDK layout (see below).
Binary packages are generated from CMake recipes. Projects are configured, compiled and installed in a temporary directory. This
temporary directory is compressed to create the binary package.
We can have runtime and development binary packages. You will always need development packages when you compile.
Runtime packages are needed to generate release archives. These only contain the data needed to start the program -
no headers, no static libs, no debug symbols...

=== Projects ===
A project is a folder containing a CMakeLists.txt and a manifest that describes the project. The manifest contains a list of build
and runtime dependencies.

Only CMake projects are supported, but you can write a CMakeLists to compile external projects.
That way you can build projects using make, autotools, jam, ...

For example, here the CMakeLists that compile protobuf:
[source, cmake]
----
cmake_minimum_required(VERSION 2.8.3)
project(ProtoBuf NONE)
include(qibuild.cmake)
qi_build_autotools(protobuf
                   "http://protobuf.googlecode.com/files/protobuf-2.3.0.tar.bz2"
                   MD5 "f2964f636b3c67d1e9d8b90819fa8ddb"
                   PATCH ${CMAKE_CURRENT_SOURCE_DIR}/0001-protobuf-fix-compilation.patch)
----

This will download, configure, compile and install protobuf in the SDK folder of your build directory. You will be
able to use use protobuf from the build/sdk directory, or generate a binary package from that.


=== WorkTree ===
To allow qiBuild to find buildable dependencies, a worktree needs to be created. A worktree is a folder containing a .qi folder.
You can add as many projects as you want to your worktree, they will be detected automatically. Your worktrees can be organised as you wish, the only important point, is to have a qibuild.manifest
file that describes each buildable project. If no .qi folder is found, qiBuild will not search for
buildable dependencies. Without a worktree, the default behavior is the same as how unix projects work: find dependencies only in the system.
image:images/qi_work_tree.png[]

=== 1,2,3 Compile ===
Now how do you combine all these concepts?

Building a project involves searching for each dependency, looking in the current toolchain for provided binary projects and build the others from source. You can add or remove a project
from your toolchain to decide if you want to build it or not.


== CMake ==
qiBuild supports multiple build directories for a given source tree. This allows you to
build for multiples platforms using the same source tree. You can have a build folder
for windows next to a build folder for linux. You will find a SDK in each build folder.
image:images/multiple_sdks.png[]

=== the SDK layout ===
This part explain what a project should generate (once compiled) to be a valid SDK. A valid SDK
is a folder where CMake can find targets, libraries and headers. An SDK folder represents one or
more projects. It contains headers, libraries, CMake modules (<name>-config.cmake files), and a
manifest to describe the contents. You will find the SDK layout in multiples places:

- each build folder contains an SDK folder (for example build-linux/sdk)
- installed projects follows the SDK layout
- binary packages follows the SDK layout

This folder follows link:http://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard[FHS] and CMake conventions.

Because the SDK layout follow CMake conventions, if you add the folder to the CMAKE_PREFIX_PATH cmake variable
in another project, all standard cmake functions to search packages, headers and libraries will works with projects
in your SDK.

image:images/sdk_layout.png[]

Because this layout follows the FHS, it allow multiples projects to be merged without conflict, furthermore
software can be installed on a link:http://en.wikipedia.org/wiki/Linux_Standard_Base[LSB]
compatible system, without breaking established convention. All qiBuild CMake functions
try to follow these rules. Install rules are autogenerated for executables and libraries.
The goal being to make it hard to write CMake that behaves badly.

Install rules have components, this allows us to generate two types of binary packages:
 - runtime binary packages
 - development binary packages


A typical layout looks like this:

----
# programs
/bin/<programs>

# libraries
/lib/<libraries>

# plugins for <project>
/lib/<project>/<libraries>

# headers
/include/<project>/

# preferences, maybe prefer /etc?
/preferences

# CMake files
/share/cmake/<projects>-config.cmake

# qibuild files
qibuild.manifest
----

=== Dependencies ===
There are two types of dependencies, project dependencies and CMake target dependencies.
Projects have CMakeLists.txt that allows them to be built, and can have multiple targets (executables or libraries).
Each target in a project can depend on other targets (in the same project or in dependent
projects specified in the manifest). For example you can have two projects A and B.
A has two targets A-lib and A-bin. B has one target B-bin. If the two targets B-bin and A-bin both
depend on A-lib, you have two target dependencies:

Part of A's CMakeLists.txt
----
# Add A-lib as a target dependency for A-bin
qi_use_lib(A-bin A-lib)
----

The above will always work because the dependency is in the same project.

Part of B's CMakeLists.txt
----
# Add A-lib as a target dependency for B-bin
qi_use_lib(B-bin A-lib)
----

When you need B's target to find one of A's target, you need to add a project dependency in B's qibuild.manifest.
[source, ini]
----
# Project dependencies
[project B]
depends = "A"
----


image:images/cross_project_dependencies.png[]





== File Formats ==
Basically there are two important file formats that we define. CMake Modules defines how CMake
finds libraries and compile with them (library paths, compiler flags, include directories, dependencies, ...).
At this level dependencies work at the target level. Now comes qibuild.manifest that describes
the content of a project or package. You can define dependencies between projects here. (a project
can contain multiples targets).


=== CMake Modules ===
For each target we generate a target-config.cmake file that enables the target to be found from
other CMake projects. In reality two config files are generated, one for build/sdk that points
to the "staged" (built but not installed) libraries. The other is for installed sdk.

==== CMake target ====
For each CMake target we export a set of specific variables.
Exported variables:

 - <TARGET>_LIBRARIES
 - <TARGET>_INCLUDE_DIRS
 - <TARGET>_DEFINITIONS

 - <TARGET>_DEPENDS : qiBuild extension to specify dependencies
 - <TARGET>_TARGET  : qiBuild extension to specify the associated CMake target name

===== Examples =====

This is a cmake module
inside an SDK (autogenerated by qiBuild):
[source, cmake]
----
set(NAOQI_INCLUDE_DIRS "/home/joe/src/qi/naoqi/build/include;
                        /home/joe/src/qi/naoqi/bindings/c;
                        /home/joe/src/qi/naoqi;"
                        CACHE STRING "" FORCE)
set(NAOQI_DEFINITIONS "" CACHE STRING "" FORCE)
set(NAOQI_LIBRARIES "optimized;/home/joe/src/qi/naoqi/build/sdk/lib/libqi.a;
                     debug;/home/joe/src/qi/naoqi/build/sdk/lib/libqi.a"
                     CACHE STRING "" FORCE)
set(NAOQI_DEPENDS "BOOST;BOOST_DATE_TIME;BOOST_THREAD;"
                   CACHE STRING "" FORCE)
set(NAOQI_TARGET "qi" CACHE STRING "" FORCE)
----


This is a cmake module that can be installed and used
everywhere:
[source, cmake]
----
get_filename_component(_ROOT_DIR ${CMAKE_CURRENT_LIST_FILE} PATH)
set(NAOQI_INCLUDE_DIRS "${_ROOT_DIR}/../../../include/"
                        CACHE STRING "" FORCE)
set(NAOQI_DEFINITIONS "" CACHE STRING "" FORCE)
set(NAOQI_DEPENDS "BOOST;BOOST_DATE_TIME;BOOST_THREAD;
                   Protobuf;ZEROMQ;UUID" CACHE STRING "" FORCE)
set(NAOQI_D_LIBRARY NAOQI_D_LIBRARY-NOTFOUND CACHE INTERNAL "" FORCE)
set(NAOQI_LIBRARY   NAOQI_LIBRARY-NOTFOUND   CACHE INTERNAL "" FORCE)

find_library(NAOQI_d_LIBRARY qi_d)
find_library(NAOQI_LIBRARY qi)
if (_qi_temp)
  set(NAOQI_LIBRARIES "optimized;${NAOQI_LIBRARY};
                       debug;${NAOQI_D_LIBRARY}")
else()
  set(NAOQI_LIBRARIES "${NAOQI_LIBRARY}")
endif()
----


=== qiBuild.manifest ===
The qiBuild.manifest file describes the contents of a project or a package.
It should provide the following information:

Required:

- project name
- buildtime dependencies
- runtime dependencies

Optional:

- cross-compilation options
- CMake toolchain file
- CMake definitions

[source, ini]
----
#sample qibuild.manifest
[project naoqiqigui]
depends = "naoqi qt4"
----
