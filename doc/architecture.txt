Architecture
============

== QiBuild ==
Qibuild is a simple tool that build projects taking dependencies and toolchains into account.

We have strong requirement for it:

* as standard as possible
* support cross-compilation
* support visual-studio
* support building for multiple plateforms with the same source tree

How does it work?

=== Toolchains ===
Toolchains are managed by QiToolchain, the default toolchain is called "system". The system
toolchain represent your system, libraries and headers will be searched in your system.
Other toolchains use binary packages.

A toolchain is composed of:

* binary packages
* a list of provided projects (a binary packages can provide multiples projects)
* optional cmake toolchain file to set cross-compilation specific options (CC, CXX, rootfs, ...)
* optional cmake flags

Each package follow a standard SDK layout (compatible with FHS and cmake guidelines).

=== Packages ===
A binary package is an archive with a manifest that describe the package (runtime dependencies,
provided packages, ...) with a standard SDK layout (see bellow).
Most of the time binary packages are generated from a cmake recipe. We have cmake wrappers around make,
jam and autotools based projects to compile external dependencies and install them in build/sdk
like pure cmake packages. This provide recipe for boost, archive, protobuf, ...

=== Projects ===
A project is a folder containing a manifest that describe the project. The manifest contain a list of build
and runtime dependencies. We only support cmake based projects. (but you could write cmake rules
to compile autotools etc.. projects).

=== WorkTree ===
To allow qibuild find buildable dependencies a worktree need to be created. A worktree is folder containing a .qi folder.
You can add as many projects as you want in your worktree, they will be detected automatically,
you can organise your worktree like you want. The only important point, is to have a qibuild.manifest
file that describe each buildable projects. If no .qi folder are found, qibuild will not search for
buildable dependencies. Without worktree it default to how unix projects works: find dependencies only in the system.

=== 1,2,3 Compile ===
Now how do you combine all the above concepts?

Building a project involve searching for each dependencies, looking in the current toolchain
which one are provided and build the others from sources. You can add or remove a project
from your toolchain to decide if you want to build it or no.

CMAKE
-----

Dependencies
~~~~~~~~~~~~
There are two types of dependencies, project dependencies and cmake target dependencies.
Projects have CMakeLists.txt that allow building them, they can have multiple targets (executable or libraries).
Each target in a project can depends on other target (in the same project or in dependents
projects specified in the manifest). For example you can have two project A and B.
A have too target A-lib and A-bin. B have one target B-bin. If the too target B-bin and A-bin
depends on A-lib, you have two target dependencies:

----
#cmake target dependencies
qi_use_lib(A-bin A-lib)
qi_use_lib(B-bin B-lib)
----

A-bin that depend on A-lib will always work between they are in the same projects, but if
you want B's target to find A's target, you need to add a project dependency (in the B manifest):

----
#project dependencies
[project B]
depends = "A"
----

Multiple build directory
~~~~~~~~~~~~~~~~~~~~~~~~
QiBuild support multiple build directories. This allow you to
build for multiples plateforms using the same source tree. You can have a build
folder for windows next to a build folder for linux.

Install rules
~~~~~~~~~~~~~
Clean install rules. Restrict the need to write install rules at the maximum.
Binaries and libraries have autogenerated install rules. Only data and headers are left
to the user. This ensure we always have the same layer.

SDK Layout
~~~~~~~~~~
You will always find a sdk folder inside your build directory. The folder is
organised following the link:http://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard[FHS].
This allow multiples projects to be merged without conflict, furthermore
software can be installed under a link:http://en.wikipedia.org/wiki/Linux_Standard_Base[LSB]
compatible system, without breaking established convention. All QiBuild CMake functions
try to follow those rules. Install rules are autogenerated for executables and libraries.
Make it hard to write bad cmake code. The sdk folder is important, if you build a project
and want another to depends on it, it only need the path to the sdk folder of the dependent
project, be it a compiled project or a binary package. This folder follow cmake guidelines,
and doing list(APPEND CMAKE_PREFIX_PATH <yourproject/build/sdk>) in another project with allow find_package,
find_path and find_library to works without tweak.

Find a project (cmake config module)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
For each target we generate a target-config.cmake file that allow finding the target from
other cmake projects. In reality two config files are generated, one for build/sdk that point
to the "staged" (build but not installed) libraries. The other is for installed sdk.

CMake target
~~~~~~~~~~~~
For each cmake target we export a set of specific variables.
Exported variables:
 - <TARGET>_LIBRARIES
 - <TARGET>_INCLUDE_DIR
 - <TARGET>_DEFINITIONS
...

Manifest
~~~~~~~~
qibuild.manifest files describes the content of a project or a package.
It should provide the following information:

Required:

- project name
- buildtime dependencies
- runtime dependencies

Optional:

- cross-compilation options
- cmake toolchain file
- cmake definitions
