## Copyright (c) 2012 Aldebaran Robotics. All rights reserved.
## Use of this source code is governed by a BSD-style license that can be
## found in the COPYING file.

""" Clean build directories.

By default all build directories for the current configuration
will be deleted for the specified project and its dependencies.

Use -s to clean the current project only
Use -c to choose a config
Use -f to force the clean
Use -z to clean all existing configurations
"""

import os
import platform

import qisys
from qisys import ui

import qibuild.parsers
import qitoolchain.toolchain

def configure_parser(parser):
    """Configure parser for this action."""
    qibuild.parsers.build_parser(parser)
    qibuild.parsers.project_parser(parser)
    parser.add_argument("-z", dest="all_toolchains", action="store_true",
                                                help="erase for all toolchains")
    parser.add_argument("--force", "-f", dest="force", action="store_true", help="force the clean")

def only_existing_dirs(dirs):
    """Return a list of existing directories from a list of dirs."""
    existing_dirs = [x for x in dirs if os.path.isdir(x)]
    return existing_dirs

def get_build_dirs(projects):
    """Returns a list of build directories."""
    bdirs = [project.build_directory for project in projects]
    return bdirs

def is_build_dir(build_worktree, build_dir):
    """ Try to guess if the fodler given as parameter has
    been generated by qibuild

    """
    parts = build_dir.split("-")
    if len(parts) == 0:
        return False

    if not parts.pop(0) == "build":
        return False

    qibuild_xml = build_worktree.qibuild_xml
    return _is_build_folder_name(parts, qibuild_xml)


def _is_build_folder_name(parts, qibuild_xml):
    """Check if the parts list match a build folder name."""

    configs = qitoolchain.toolchain.get_tc_names()
    profiles = qibuild.profile.parse_profiles(qibuild_xml).keys()
    build_types=["release"]

    if len(parts) == 0:
        return False

    if parts[0] == "sys":
        if len(parts) < 3:
            return False
        if not parts[1] == platform.system().lower() or \
           not parts[2] == platform.machine().lower():
            return False
        else:
            parts = parts[3:]
    elif parts[0] in configs:
        parts = parts[1:]
    else:
        return False

    while len(parts) != 0 and parts[0] in profiles:
        parts = parts[1:]

    if len(parts) == 0:
        return True

    if parts[0].lower() not in build_types:
        return False
    else:
        parts = parts[1:]

    return len(parts) == 0

@ui.timer("qibuild clean")
def do(args):
    """Main entry point."""
    build_worktree = qibuild.parsers.get_build_worktree(args)
    projects = qibuild.parsers.get_build_projects(build_worktree, args)

    if args.all_toolchains:
        bdirs = list()
        for project in projects:
            dirs = os.listdir(project.path)
            bdirs.extend([os.path.join(project.path, x) for x in dirs if
                os.path.isdir(os.path.join(project.path, x)) and
                                      is_build_dir(build_worktree, x)])
    else:
        bdirs = get_build_dirs(projects)

    bdirs = only_existing_dirs(bdirs)
    bdir_count = len(bdirs)

    if bdir_count == 0:
        ui.info(ui.green, "No directory to clean")
    elif not args.force:
        ui.info(ui.green, "Build directories that will be removed", ui.reset, ui.bold, "(use -f to apply):")

    for i, bdir in enumerate(bdirs, start=1):
        to_print = [ui.green, "*", ui.reset, "(%i/%i)" % (i, bdir_count)]
        if args.force:
            to_print.extend([ui.green, "Cleaning", ui.reset, bdir])

            # delete the build directory
            qisys.sh.rm(bdir)
        else:
            to_print.extend([ui.reset, bdir])
        ui.info(*to_print)
